{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Requests-HTMLC: Fork of Requests-HTML, using PlayWright","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>See the github repository for a summary of whats possible with this library.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>Click here to jump to the api docs!</p>"},{"location":"requests-htmlc/requests_html/","title":"requests_html","text":""},{"location":"requests-htmlc/requests_html/#requests_html","title":"<code>requests_html</code>","text":""},{"location":"requests-htmlc/requests_html/#requests_html.AsyncHTMLSession","title":"<code>AsyncHTMLSession(loop=None, workers=None, mock_browser=True, *args, **kwargs)</code>","text":"<p>             Bases: <code>BaseSession</code></p> <p>An async consumable session.</p> <p>Set or create an event loop and a thread pool.</p> <p>Parameters:</p> <ul> <li> <code>loop</code>             (<code>Optional[AbstractEventLoop]</code>, default:                 <code>None</code> )         \u2013          <p>Asyncio loop to use.</p> </li> <li> <code>workers</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Amount of threads to use for executing async calls. If not pass it will default to the number of processors on the machine, multiplied by 5.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def __init__(\n    self,\n    loop: Optional[AbstractEventLoop] = None,\n    workers: Optional[int] = None,\n    mock_browser: bool = True,\n    *args,\n    **kwargs,\n):\n    \"\"\"Set or create an event loop and a thread pool.\n\n    Args:\n        loop (Optional[AbstractEventLoop], optional): Asyncio loop to use.\n        workers (Optional[int], optional): Amount of threads to use for executing async calls.\n            If not pass it will default to the number of processors on the\n            machine, multiplied by 5.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    self.loop = loop or asyncio.get_event_loop()\n    self.thread_pool = ThreadPoolExecutor(max_workers=workers)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.AsyncHTMLSession.close","title":"<code>close()</code>  <code>async</code>","text":"<p>If a browser was created close it first.</p> Source code in <code>requests_html.py</code> <pre><code>async def close(self):\n    \"\"\"If a browser was created close it first.\"\"\"\n    if hasattr(self, \"_browser\"):\n        await self._browser.close()\n        await self._playwright.stop()\n    super().close()\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.AsyncHTMLSession.request","title":"<code>request(*args, **kwargs)</code>","text":"<p>Partial original request func and run it in a thread.</p> Source code in <code>requests_html.py</code> <pre><code>def request(self, *args, **kwargs):\n    \"\"\"Partial original request func and run it in a thread.\"\"\"\n    func = partial(super().request, *args, **kwargs)\n    return self.loop.run_in_executor(self.thread_pool, func)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.AsyncHTMLSession.run","title":"<code>run(*coros)</code>","text":"<p>Pass in all the coroutines you want to run, it will wrap each one in a task, run it and wait for the result. Return a list with all results, this is returned in the same order coros are passed in.</p> Source code in <code>requests_html.py</code> <pre><code>def run(self, *coros):\n    \"\"\"\n    Pass in all the coroutines you want to run, it will wrap each one\n    in a task, run it and wait for the result. Return a list with all\n    results, this is returned in the same order coros are passed in.\n    \"\"\"\n    tasks = [asyncio.ensure_future(coro()) for coro in coros]\n    done, _ = self.loop.run_until_complete(asyncio.wait(tasks))\n    return [t.result() for t in done]\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser","title":"<code>BaseParser(*, element, default_encoding=None, html=None, url)</code>","text":"<p>A basic HTML/Element Parser, for Humans.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Any</code>)         \u2013          <p>The element from which to base the parsing upon.</p> </li> <li> <code>default_encoding</code>             (<code>_DefaultEncoding</code>, default:                 <code>None</code> )         \u2013          <p>Which encoding to default to.</p> </li> <li> <code>html</code>             (<code>_HTML</code>, default:                 <code>None</code> )         \u2013          <p>HTML from which to base the parsing upon (optional).</p> </li> <li> <code>url</code>             (<code>_URL</code>)         \u2013          <p>The URL from which the HTML originated, used for <code>absolute_links</code>.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def __init__(\n    self,\n    *,\n    element,\n    default_encoding: _DefaultEncoding = None,\n    html: _HTML = None,\n    url: _URL,\n) -&gt; None:\n    self.element = element\n    self.url = url\n    self.skip_anchors = True\n    self.default_encoding = default_encoding\n    self._encoding = None\n    self._html = html.encode(DEFAULT_ENCODING) if isinstance(html, str) else html\n    self._lxml = None\n    self._pq = None\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.absolute_links","title":"<code>absolute_links: _Links</code>  <code>property</code>","text":"<p>All found links on page, in absolute form (<code>learn more &lt;https://www.navegabem.com/absolute-or-relative-links.html&gt;</code>_).</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.base_url","title":"<code>base_url: _URL</code>  <code>property</code>","text":"<p>The base URL for the page. Supports the <code>&lt;base&gt;</code> tag (<code>learn more &lt;https://www.w3schools.com/tags/tag_base.asp&gt;</code>_).</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.encoding","title":"<code>encoding: _Encoding</code>  <code>property</code> <code>writable</code>","text":"<p>The encoding string to be used, extracted from the HTML and <code>HTMLResponse &lt;HTMLResponse&gt;</code> headers.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.full_text","title":"<code>full_text: _Text</code>  <code>property</code>","text":"<p>The full text content (including links) of the <code>Element &lt;Element&gt;</code> or <code>HTML &lt;HTML&gt;</code>.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.html","title":"<code>html: _BaseHTML</code>  <code>property</code> <code>writable</code>","text":"<p>Unicode representation of the HTML content (<code>learn more &lt;http://www.diveintopython3.net/strings.html&gt;</code>_).</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.links","title":"<code>links: _Links</code>  <code>property</code>","text":"<p>All found links on page, in as\u2013is form.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.lxml","title":"<code>lxml: HtmlElement</code>  <code>property</code>","text":"<p><code>lxml &lt;http://lxml.de&gt;</code>_ representation of the <code>Element &lt;Element&gt;</code> or <code>HTML &lt;HTML&gt;</code>.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.pq","title":"<code>pq: PyQuery</code>  <code>property</code>","text":"<p><code>PyQuery &lt;https://pythonhosted.org/pyquery/&gt;</code>_ representation of the <code>Element &lt;Element&gt;</code> or <code>HTML &lt;HTML&gt;</code>.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.raw_html","title":"<code>raw_html: _RawHTML</code>  <code>property</code> <code>writable</code>","text":"<p>Bytes representation of the HTML content. (<code>learn more &lt;http://www.diveintopython3.net/strings.html&gt;</code>_).</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.text","title":"<code>text: _Text</code>  <code>property</code>","text":"<p>The text content of the <code>Element &lt;Element&gt;</code> or <code>HTML &lt;HTML&gt;</code>.</p>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.find","title":"<code>find(selector='*', *, containing=None, clean=False, first=False, _encoding=None)</code>","text":"<p>Given a CSS Selector, returns a list of <code>Element &lt;Element&gt;</code> objects or a single one.</p> <p>Parameters:</p> <ul> <li> <code>selector</code>             (<code>str</code>, default:                 <code>'*'</code> )         \u2013          <p>CSS Selector to use.</p> </li> <li> <code>clean</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to sanitize the found HTML of <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags.</p> </li> <li> <code>containing</code>             (<code>_Containing</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only return elements that contain the provided text.</p> </li> <li> <code>first</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to return just the first result.</p> </li> <li> <code>_encoding</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The encoding format. Defaults to None</p> </li> </ul> <p>Example CSS Selectors:</p> <ul> <li><code>a</code></li> <li><code>a.someClass</code></li> <li><code>a#someID</code></li> <li><code>a[target=_blank]</code></li> </ul> <p>See W3School's <code>CSS Selectors Reference &lt;https://www.w3schools.com/cssref/css_selectors.asp&gt;</code>_ for more details.</p> <p>If <code>first</code> is <code>True</code>, only returns the first <code>Element &lt;Element&gt;</code> found.</p> Source code in <code>requests_html.py</code> <pre><code>def find(\n    self,\n    selector: str = \"*\",\n    *,\n    containing: _Containing = None,\n    clean: bool = False,\n    first: bool = False,\n    _encoding: str = None,\n) -&gt; _Find:\n    \"\"\"Given a CSS Selector, returns a list of\n    `Element &lt;Element&gt;` objects or a single one.\n\n    Args:\n        selector (str, optional): CSS Selector to use.\n        clean (bool, optional): Whether or not to sanitize the found HTML of `&lt;script&gt;` and `&lt;style&gt;` tags.\n        containing (_Containing, optional): If specified, only return elements that contain the provided text.\n        first (bool, optional): Whether or not to return just the first result.\n        _encoding (str, optional): The encoding format. Defaults to None\n\n    Example CSS Selectors:\n\n    - `a`\n    - `a.someClass`\n    - `a#someID`\n    - `a[target=_blank]`\n\n    See W3School's `CSS Selectors Reference\n    &lt;https://www.w3schools.com/cssref/css_selectors.asp&gt;`_\n    for more details.\n\n    If `first` is `True`, only returns the first\n    `Element &lt;Element&gt;` found.\n    \"\"\"\n\n    # Convert a single containing into a list.\n    if isinstance(containing, str):\n        containing = [containing]\n\n    encoding = _encoding or self.encoding\n    elements = [\n        Element(element=found, url=self.url, default_encoding=encoding)\n        for found in self.pq(selector)\n    ]\n\n    if containing:\n        elements_copy = elements.copy()\n        elements = []\n\n        for element in elements_copy:\n            if any([c.lower() in element.full_text.lower() for c in containing]):\n                elements.append(element)\n\n        elements.reverse()\n\n    # Sanitize the found HTML.\n    if clean:\n        elements_copy = elements.copy()\n        elements = []\n\n        for element in elements_copy:\n            element.raw_html = lxml_html_tostring(cleaner.clean_html(element.lxml))\n            elements.append(element)\n\n    return _get_first_or_list(elements, first)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.search","title":"<code>search(template)</code>","text":"<p>Search the <code>Element &lt;Element&gt;</code> for the given Parse template.</p> <p>Parameters:</p> <ul> <li> <code>template</code>             (<code>str</code>)         \u2013          <p>The Parse template to use.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def search(self, template: str) -&gt; Result:\n    \"\"\"Search the `Element &lt;Element&gt;` for the given Parse template.\n\n    Args:\n        template (str): The Parse template to use.\n    \"\"\"\n\n    return parse_search(template, self.html)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.search_all","title":"<code>search_all(template)</code>","text":"<p>Search the <code>Element &lt;Element&gt;</code> (multiple times) for the given parse template.</p> <p>Parameters:</p> <ul> <li> <code>template</code>             (<code>str</code>)         \u2013          <p>The Parse template to use.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def search_all(self, template: str) -&gt; _Result:\n    \"\"\"Search the `Element &lt;Element&gt;` (multiple times) for the given parse\n    template.\n\n    Args:\n        template (str): The Parse template to use.\n    \"\"\"\n    return [r for r in findall(template, self.html)]\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseParser.xpath","title":"<code>xpath(selector, *, clean=False, first=False, _encoding=None)</code>","text":"<p>Given an XPath selector, returns a list of <code>Element &lt;Element&gt;</code> objects or a single one.</p> <p>Parameters:</p> <ul> <li> <code>selector</code>             (<code>str</code>)         \u2013          <p>XPath Selector to use.</p> </li> <li> <code>clean</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to sanitize the found HTML of <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags.</p> </li> <li> <code>first</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to return just the first result.</p> </li> <li> <code>_encoding</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The encoding format.</p> </li> </ul> <p>If a sub-selector is specified (e.g. <code>//a/@href</code>), a simple list of results is returned.</p> <p>See W3School's <code>XPath Examples &lt;https://www.w3schools.com/xml/xpath_examples.asp&gt;</code>_ for more details.</p> <p>If <code>first</code> is <code>True</code>, only returns the first <code>Element &lt;Element&gt;</code> found.</p> Source code in <code>requests_html.py</code> <pre><code>def xpath(\n    self,\n    selector: str,\n    *,\n    clean: bool = False,\n    first: bool = False,\n    _encoding: str = None,\n) -&gt; _XPath:\n    \"\"\"Given an XPath selector, returns a list of\n    `Element &lt;Element&gt;` objects or a single one.\n\n    Args:\n        selector (str): XPath Selector to use.\n        clean (bool, optional): Whether or not to sanitize the found HTML of `&lt;script&gt;` and `&lt;style&gt;` tags.\n        first (bool, optional): Whether or not to return just the first result.\n        _encoding (str, optional): The encoding format.\n\n    If a sub-selector is specified (e.g. `//a/@href`), a simple\n    list of results is returned.\n\n    See W3School's `XPath Examples\n    &lt;https://www.w3schools.com/xml/xpath_examples.asp&gt;`_\n    for more details.\n\n    If `first` is `True`, only returns the first\n    `Element &lt;Element&gt;` found.\n    \"\"\"\n    selected = self.lxml.xpath(selector)\n\n    elements = [\n        (\n            Element(\n                element=selection,\n                url=self.url,\n                default_encoding=_encoding or self.encoding,\n            )\n            if not isinstance(selection, etree._ElementUnicodeResult)\n            else str(selection)\n        )\n        for selection in selected\n    ]\n\n    # Sanitize the found HTML.\n    if clean:\n        elements_copy = elements.copy()\n        elements = []\n\n        for element in elements_copy:\n            element.raw_html = lxml_html_tostring(cleaner.clean_html(element.lxml))\n            elements.append(element)\n\n    return _get_first_or_list(elements, first)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseSession","title":"<code>BaseSession(mock_browser=True, verify=True, browser_args=['--no-sandbox'])</code>","text":"<p>             Bases: <code>Session</code></p> <p>A consumable session, for cookie persistence and connection pooling, amongst other things.</p> Source code in <code>requests_html.py</code> <pre><code>def __init__(\n    self,\n    mock_browser: bool = True,\n    verify: bool = True,\n    browser_args: list = [\"--no-sandbox\"],\n):\n    super().__init__()\n\n    # Mock a web browser's user agent.\n    if mock_browser:\n        self.headers[\"User-Agent\"] = user_agent()\n\n    self.hooks[\"response\"].append(self.response_hook)\n    self.verify = verify\n\n    self.__browser_args = browser_args\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.BaseSession.response_hook","title":"<code>response_hook(response, **kwargs)</code>","text":"<p>Change response encoding and replace it by a HTMLResponse.</p> Source code in <code>requests_html.py</code> <pre><code>def response_hook(self, response, **kwargs) -&gt; HTMLResponse:\n    \"\"\"Change response encoding and replace it by a HTMLResponse.\"\"\"\n    if not response.encoding:\n        response.encoding = DEFAULT_ENCODING\n    return HTMLResponse._from_response(response, self)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.Element","title":"<code>Element(*, element, url, default_encoding=None)</code>","text":"<p>             Bases: <code>BaseParser</code></p> <p>An element of HTML.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Any</code>)         \u2013          <p>The element from which to base the parsing upon.</p> </li> <li> <code>url</code>             (<code>_URL</code>)         \u2013          <p>The URL from which the HTML originated, used for <code>absolute_links</code>.</p> </li> <li> <code>default_encoding</code>             (<code>_DefaultEncoding</code>, default:                 <code>None</code> )         \u2013          <p>Which encoding to default to. Defaults to None.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def __init__(\n    self, *, element, url: _URL, default_encoding: _DefaultEncoding = None\n) -&gt; None:\n    \"\"\"An element of HTML.\n\n    Args:\n        element (Any): The element from which to base the parsing upon.\n        url (_URL): The URL from which the HTML originated, used for `absolute_links`.\n        default_encoding (_DefaultEncoding, optional): Which encoding to default to. Defaults to None.\n    \"\"\"\n    super(Element, self).__init__(\n        element=element, url=url, default_encoding=default_encoding\n    )\n    self.element = element\n    self.tag = element.tag\n    self.lineno = element.sourceline\n    self._attrs = None\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.Element.attrs","title":"<code>attrs: _Attrs</code>  <code>property</code>","text":"<p>Returns a dictionary of the attributes of the <code>Element &lt;Element&gt;</code> (<code>learn more &lt;https://www.w3schools.com/tags/ref_attributes.asp&gt;</code>_).</p>"},{"location":"requests-htmlc/requests_html/#requests_html.HTML","title":"<code>HTML(*, session=None, url=DEFAULT_URL, html, default_encoding=DEFAULT_ENCODING, async_=False)</code>","text":"<p>             Bases: <code>BaseParser</code></p> <p>An HTML document, ready for parsing.</p> <p>Parameters:</p> <ul> <li> <code>url</code>             (<code>str</code>, default:                 <code>DEFAULT_URL</code> )         \u2013          <p>The URL from which the HTML originated, used for <code>absolute_links</code>.</p> </li> <li> <code>html</code>             (<code>_HTML</code>)         \u2013          <p>HTML from which to base the parsing upon (optional).</p> </li> <li> <code>default_encoding</code>             (<code>str</code>, default:                 <code>DEFAULT_ENCODING</code> )         \u2013          <p>Which encoding to default to.</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def __init__(\n    self,\n    *,\n    session: Union[\"HTMLSession\", \"AsyncHTMLSession\"] = None,\n    url: str = DEFAULT_URL,\n    html: _HTML,\n    default_encoding: str = DEFAULT_ENCODING,\n    async_: bool = False,\n) -&gt; None:\n    \"\"\"An HTML document, ready for parsing.\n\n    Args:\n        url (str, optional): The URL from which the HTML originated, used for `absolute_links`.\n        html (_HTML, optional): HTML from which to base the parsing upon (optional).\n        default_encoding (str, optional): Which encoding to default to.\n    \"\"\"\n\n    # Convert incoming unicode HTML into bytes.\n    if isinstance(html, str):\n        html = html.encode(DEFAULT_ENCODING)\n\n    pq = PyQuery(html)\n    super(HTML, self).__init__(\n        element=pq(\"html\") or pq.wrapAll(\"&lt;html&gt;&lt;/html&gt;\")(\"html\"),\n        html=html,\n        url=url,\n        default_encoding=default_encoding,\n    )\n    self.session = session or async_ and AsyncHTMLSession() or HTMLSession()\n    self.page = None\n    self.next_symbol = DEFAULT_NEXT_SYMBOL\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTML.arender","title":"<code>arender(retries=8, script=None, wait=0.2, scrolldown=False, sleep=0, reload=True, timeout=8.0, keep_page=False, cookies=[{}], send_cookies_session=False)</code>  <code>async</code>","text":"<p>Async version of render. Takes same parameters.</p> Source code in <code>requests_html.py</code> <pre><code>async def arender(\n    self,\n    retries: int = 8,\n    script: str = None,\n    wait: float = 0.2,\n    scrolldown=False,\n    sleep: int = 0,\n    reload: bool = True,\n    timeout: Union[float, int] = 8.0,\n    keep_page: bool = False,\n    cookies: list = [{}],\n    send_cookies_session: bool = False,\n):\n    \"\"\"Async version of render. Takes same parameters.\"\"\"\n\n    self.browser = await self.session.browser\n    content = None\n\n    # Automatically set Reload to False, if example URL is being used.\n    if self.url == DEFAULT_URL:\n        reload = False\n\n    if send_cookies_session:\n        cookies = self._convert_cookiesjar_to_render()\n\n    for _ in range(retries):\n        if not content:\n            try:\n\n                content, result, page = await self._async_render(\n                    url=self.url,\n                    script=script,\n                    sleep=sleep,\n                    wait=wait,\n                    content=self.html,\n                    reload=reload,\n                    scrolldown=scrolldown,\n                    timeout=timeout,\n                    keep_page=keep_page,\n                    cookies=cookies,\n                )\n            except TypeError:\n                pass\n        else:\n            break\n\n    if not content:\n        raise MaxRetries(\"Unable to render the page. Try increasing timeout\")\n\n    html = HTML(\n        url=self.url,\n        html=content.encode(DEFAULT_ENCODING),\n        default_encoding=DEFAULT_ENCODING,\n    )\n    self.__dict__.update(html.__dict__)\n    self.page = page\n    return result\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTML.next","title":"<code>next(fetch=False, next_symbol=None)</code>","text":"<p>Attempts to find the next page, if there is one. If <code>fetch</code> is <code>True</code> (default), returns <code>HTML &lt;HTML&gt;</code> object of next page. If <code>fetch</code> is <code>False</code>, simply returns the next URL.</p> <p>Parameters:</p> <ul> <li> <code>fetch</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>dictates whether to fetch the next page, or return next url</p> </li> <li> <code>next_symbol</code>             (<code>_NextSymbol</code>, default:                 <code>None</code> )         \u2013          <p>if specified, only fetch elements containing this text value</p> </li> </ul> Source code in <code>requests_html.py</code> <pre><code>def next(self, fetch: bool = False, next_symbol: _NextSymbol = None) -&gt; _Next:\n    \"\"\"Attempts to find the next page, if there is one. If `fetch`\n    is `True` (default), returns `HTML &lt;HTML&gt;` object of\n    next page. If `fetch` is `False`, simply returns the next URL.\n\n    Args:\n        fetch (bool, optional): dictates whether to fetch the next page, or return next url\n        next_symbol (_NextSymbol, optional): if specified, only fetch elements containing this text value\n    \"\"\"\n\n    if next_symbol is None:\n        next_symbol = DEFAULT_NEXT_SYMBOL\n\n    def get_next():\n        candidates = self.find(\"a\", containing=next_symbol)\n\n        for candidate in candidates:\n            if candidate.attrs.get(\"href\"):\n                # Support 'next' rel (e.g. reddit).\n                if \"next\" in candidate.attrs.get(\"rel\", []):\n                    return candidate.attrs[\"href\"]\n\n                # Support 'next' in classnames.\n                for _class in candidate.attrs.get(\"class\", []):\n                    if \"next\" in _class:\n                        return candidate.attrs[\"href\"]\n\n                if \"page\" in candidate.attrs[\"href\"]:\n                    return candidate.attrs[\"href\"]\n\n        try:\n            # Resort to the last candidate.\n            return candidates[-1].attrs[\"href\"]\n        except IndexError:\n            return None\n\n    __next = get_next()\n    if __next:\n        url = self._make_absolute(__next)\n    else:\n        return None\n\n    if fetch:\n        return self.session.get(url)\n    else:\n        return url\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTML.render","title":"<code>render(retries=8, script=None, wait=0.2, scrolldown=False, sleep=0, reload=True, timeout=8.0, keep_page=False, cookies=[{}], send_cookies_session=False)</code>","text":"<p>Reloads the response in Chromium, and replaces HTML content with an updated version, with JavaScript executed.</p> <p>Parameters:</p> <ul> <li> <code>retries</code>             (<code>int</code>, default:                 <code>8</code> )         \u2013          <p>The number of times to retry loading the page in Chromium.</p> </li> <li> <code>script</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>JavaScript to execute upon page load (optional).</p> </li> <li> <code>wait</code>             (<code>float</code>, default:                 <code>0.2</code> )         \u2013          <p>The number of seconds to wait before loading the page, preventing timeouts (optional).</p> </li> <li> <code>scrolldown</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Integer, if provided, of how many times to page down.</p> </li> <li> <code>sleep</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Integer, if provided, of how many seconds to sleep after initial render.</p> </li> <li> <code>reload</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>False</code>, content will not be loaded from the browser, but will be provided from memory.</p> </li> <li> <code>timeout</code>             (<code>Union[float, int]</code>, default:                 <code>8.0</code> )         \u2013          <p>specify a timeout for the render</p> </li> <li> <code>keep_page</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code> will allow you to interact with the browser page through <code>r.html.page</code>.</p> </li> <li> <code>send_cookies_session</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code> send <code>HTMLSession.cookies</code> convert.</p> </li> <li> <code>cookies</code>             (<code>list</code>, default:                 <code>[{}]</code> )         \u2013          <p>If not <code>empty</code> send <code>cookies</code>.</p> </li> </ul> <p>If <code>scrolldown</code> is specified, the page will scrolldown the specified number of times, after sleeping the specified amount of time (e.g. <code>scrolldown=10, sleep=1</code>).</p> <p>If just <code>sleep</code> is provided, the rendering will wait n seconds, before returning.</p> <p>If <code>script</code> is specified, it will execute the provided JavaScript at runtime. Example:</p> <pre><code>    script = \"\"\"\n        () =&gt; {\n            return {\n                width: document.documentElement.clientWidth,\n                height: document.documentElement.clientHeight,\n                deviceScaleFactor: window.devicePixelRatio,\n            }\n        }\n    \"\"\"\n</code></pre> <p>Returns the return value of the executed  <code>script</code>, if any is provided:</p> <pre><code>    &gt;&gt;&gt; r.html.render(script=script)\n    {'width': 800, 'height': 600, 'deviceScaleFactor': 1}\n</code></pre> <p>Note: method requires that you have run <code>playwright install</code></p> Source code in <code>requests_html.py</code> <pre><code>def render(\n    self,\n    retries: int = 8,\n    script: str = None,\n    wait: float = 0.2,\n    scrolldown=False,\n    sleep: int = 0,\n    reload: bool = True,\n    timeout: Union[float, int] = 8.0,\n    keep_page: bool = False,\n    cookies: list = [{}],\n    send_cookies_session: bool = False,\n):\n    \"\"\"Reloads the response in Chromium, and replaces HTML content\n    with an updated version, with JavaScript executed.\n\n    Args:\n        retries (int, optional): The number of times to retry loading the page in Chromium.\n        script (str, optional): JavaScript to execute upon page load (optional).\n        wait (float, optional): The number of seconds to wait before loading the page, preventing timeouts (optional).\n        scrolldown (bool, optional): Integer, if provided, of how many times to page down.\n        sleep (int, optional): Integer, if provided, of how many seconds to sleep after initial render.\n        reload (bool, optional): If `False`, content will not be loaded from the browser, but will be provided from memory.\n        timeout (Union[float, int], optional): specify a timeout for the render\n        keep_page (bool, optional): If `True` will allow you to interact with the browser page through `r.html.page`.\n        send_cookies_session (bool, optional): If `True` send `HTMLSession.cookies` convert.\n        cookies (list, optional): If not `empty` send `cookies`.\n\n    If `scrolldown` is specified, the page will scrolldown the specified\n    number of times, after sleeping the specified amount of time\n    (e.g. `scrolldown=10, sleep=1`).\n\n    If just `sleep` is provided, the rendering will wait *n* seconds, before\n    returning.\n\n    If `script` is specified, it will execute the provided JavaScript at\n    runtime. Example:\n\n\n    ```python\n        script = \\\"\\\"\\\"\n            () =&gt; {\n                return {\n                    width: document.documentElement.clientWidth,\n                    height: document.documentElement.clientHeight,\n                    deviceScaleFactor: window.devicePixelRatio,\n                }\n            }\n        \\\"\\\"\\\"\n    ```\n\n    Returns the return value of the executed  `script`, if any is provided:\n\n    ```python\n        &gt;&gt;&gt; r.html.render(script=script)\n        {'width': 800, 'height': 600, 'deviceScaleFactor': 1}\n    ```\n\n    Note: method requires that you have run `playwright install`\n    \"\"\"\n\n    self.browser = (\n        self.session.browser\n    )  # Automatically create a event loop and browser\n    content = None\n\n    # Automatically set Reload to False, if example URL is being used.\n    if self.url == DEFAULT_URL:\n        reload = False\n\n    if send_cookies_session:\n        cookies = self._convert_cookiesjar_to_render()\n\n    for i in range(retries):\n        if not content:\n            try:\n\n                content, result, page = self.session.loop.run_until_complete(\n                    self._async_render(\n                        url=self.url,\n                        script=script,\n                        sleep=sleep,\n                        wait=wait,\n                        content=self.html,\n                        reload=reload,\n                        scrolldown=scrolldown,\n                        timeout=timeout,\n                        keep_page=keep_page,\n                        cookies=cookies,\n                    )\n                )\n            except TypeError:\n                pass\n        else:\n            break\n\n    if not content:\n        raise MaxRetries(\"Unable to render the page. Try increasing timeout\")\n\n    html = HTML(\n        url=self.url,\n        html=content.encode(DEFAULT_ENCODING),\n        default_encoding=DEFAULT_ENCODING,\n    )\n    self.__dict__.update(html.__dict__)\n    self.page = page\n    return result\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTMLResponse","title":"<code>HTMLResponse(session)</code>","text":"<p>             Bases: <code>Response</code></p> <p>An HTML-enabled <code>requests.Response &lt;requests.Response&gt;</code> object. Effectively the same, but with an intelligent <code>.html</code> property added.</p> Source code in <code>requests_html.py</code> <pre><code>def __init__(self, session: Union[\"HTMLSession\", \"AsyncHTMLSession\"]) -&gt; None:\n    super(HTMLResponse, self).__init__()\n    self._html = None  # type: HTML\n    self.session = session\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTMLSession","title":"<code>HTMLSession(**kwargs)</code>","text":"<p>             Bases: <code>BaseSession</code></p> Source code in <code>requests_html.py</code> <pre><code>def __init__(self, **kwargs):\n    super(HTMLSession, self).__init__(**kwargs)\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.HTMLSession.close","title":"<code>close()</code>","text":"<p>If a browser was created close it first.</p> Source code in <code>requests_html.py</code> <pre><code>def close(self):\n    \"\"\"If a browser was created close it first.\"\"\"\n    if hasattr(self, \"_browser\"):\n        self.loop.run_until_complete(self._browser.close())\n        self.loop.run_until_complete(self._playwright.stop())\n    super().close()\n</code></pre>"},{"location":"requests-htmlc/requests_html/#requests_html.user_agent","title":"<code>user_agent(style=None)</code>","text":"<p>Returns an apparently legit user-agent, if not requested one of a specific style. Defaults to a Chrome-style User-Agent.</p> Source code in <code>requests_html.py</code> <pre><code>def user_agent(style=None) -&gt; _UserAgent:\n    \"\"\"Returns an apparently legit user-agent, if not requested one of a specific\n    style. Defaults to a Chrome-style User-Agent.\n    \"\"\"\n    global useragent\n    if (not useragent) and style:\n        useragent = UserAgent()\n\n    return useragent[style] if style else DEFAULT_USER_AGENT\n</code></pre>"}]}